## 背景
软件开发最大的麻烦事之一，就是环境配置。想让软件跑起来就要保证操作系统的设置，各种库和组件的安装都正确
所谓虚拟机就是能够带环境安装的一种方案，比如在 Windows 系统里面运行 Linux 系统。应用程序对此毫无感知，因为虚拟机看上去跟真实系统一模一样，而对于底层系统来说，虚拟机就是一个普通文件，不需要了就删掉，对其他部分毫无影响。
但是虚拟器仍然存在一些问题
	1. 资源占用多
	虚拟机会独占一部分内存和硬盘空间。它运行的时候，其他程序就不能使用这些资源了。哪怕虚拟机里面的应用程序，真正使用的内存只有 1MB，虚拟机依然需要几百 MB 的内存才能运行。
	2. 冗余步骤多
	虚拟机是完整的操作系统，一些系统级别的操作步骤，往往无法跳过，比如用户登录。
	3. 启动慢
	启动操作系统需要多久，启动虚拟机就需要多久。可能要等几分钟，应用程序才能真正运行。
因此发展出了另一种虚拟化技术，容器不是模拟一个完整的操作系统，而是对进程进行隔离。或者说，在正常进程的外面套了一个保护层。对于容器里面的进程来说，它接触到的各种资源都是虚拟的，从而实现与底层系统的隔离。
由于容器是进程级别的，相比虚拟机有很多优势。
	1. 启动快
	容器里面的应用，直接就是底层系统的一个进程，而不是虚拟机内部的进程。所以，启动容器相当于启动本机的一个进程，而不是启动一个操作系统，速度就快很多。
	2. 资源占用少
	容器只占用需要的资源，不占用那些没有用到的资源；虚拟机由于是完整的操作系统，不可避免要占用所有资源。另外，多个容器可以共享资源，虚拟机都是独享资源。
	3. 体积小
	容器只要包含用到的组件即可，而虚拟机是整个操作系统的打包，所以容器文件比虚拟机文件要小很多。
[Docker](https://www.docker.com/)属于 Linux 容器的一种封装，提供简单易用的容器使用接口
## image 文件
Docker 把应用程序及其依赖，打包在 image 文件里面。只有通过这个文件，才能生成 Docker 容器。image 文件可以看作是容器的模板。Docker 根据 image 文件生成容器的实例。同一个 image 文件，可以生成多个同时运行的容器实例。
```bash 
# 列出本机的所有 image 文件。
$ docker image ls

# 删除 image 文件
$ docker image rm [imageName]
```
## 实例：hello world
首先将 image 文件从仓库抓取到本地。
```bash
$ docker image pull library/hello-world
```
抓取成功以后，就可以在本机看到这个 image 文件了。 
```bash
> $ docker image ls
> ```
```bash
$ docker container run hello-world
```
`docker container run`命令会从 image 文件，生成一个正在运行的容器实例。

## 容器文件
image 文件生成的容器实例，本身也是一个文件，称为容器文件。也就是说，一旦容器生成，就会同时存在两个文件： image 文件和容器文件。而且关闭容器并不会删除容器文件，只是容器停止运行而已。
```bash
# 列出本机正在运行的容器
$ docker container ls

# 列出本机所有容器，包括终止运行的容器
$ docker container ls --all
```
终止运行的容器文件，依然会占据硬盘空间，可以使用[`docker container rm`](https://docs.docker.com/engine/reference/commandline/container_rm/)命令删除。
```bash
$ docker container rm [containerID]
```

## 制作一个Docker容器
