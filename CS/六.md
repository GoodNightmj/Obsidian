![image.png](https://raw.githubusercontent.com/GoodNightmj/PicGo/master/202412111402309.png)
### Array Doubling
假设一开始数组大小为2，需要时将大小扩大1倍
已知当前数组中已有n元素n=2^k，当插入n+1元素时需要扩大
对于一开始的2^1元素，需要移动2^k次（越早的次数越多）
$$
\sum_{i=1}^{k-1} =2^i *(k-i) +2^1*k
$$
2S-S得
S=2n-2复杂度为On
![image.png](https://raw.githubusercontent.com/GoodNightmj/PicGo/master/202412111433504.png)



### 红黑树
定义：
1.是一个二叉排序树
2.每个节点不是黑色就是红色
3.根节点是黑色
4.所有外部节点都是黑色空树，代表查找失败
5.红结点不能有红孩子，即不可有两个连续的红结点
6.树中每一个结点u，他的所有外部路径的black length相同
关键性质
从根到叶子的最长可能路径不多于最短的可能路径的两倍长
因此在大致上是平衡的
插入：
1.将新插入结点标记为红色
2.如果新插入的结点是根节点，则标记为黑色
3.如果他的parent是黑色，结束
4.如果他的parent是红色
	uncle也为红色
		先将uncle和parent标记为黑色，再将gf标记为红色
	 uncle不存在或为黑
		 通过grandpa进行旋转变为红色，parent颜色变为黑色




### 优先队列
定义：一种特殊的队列。在优先队列中，元素被赋予优先级，队列是0个或多个元素的集合

操作：
1）Get-min：取队列的优先级最小的元素
2）Delete-min: 删除优先级最小的
3)Insert :插入一个新元素
4)decrecase key：修改队列中元素的权值

#### 有序线性表
1.查找和删除都是O(1)，取队尾
2.插入
	找到插入位置，二分
	移动元素，平均为（n+1）/2 O(n)

#### 堆
1.取堆顶，O（1）
2.删除堆顶，插入堆顶都是 O(logn)调整堆
4.调整权值
	找到该元素，O(n)
	修改后调整堆 O（logn）
使用辅助数组构建每个元素的id和堆数组的位置使找到元素的复杂度为O（2）

### 等价类和最小生成树
1.从m条边中选择一个权值最小的比较m-1次，判断是否有回路
2.从m-1条边中选择最小的，m-2次比较。

最坏情况为比较了(m-1)+...1=m(m-1)/2次比较
在判断是否有回路时使用深搜，时间复杂度为O（n+m）最坏情况下进行了m次，时间复杂度为O（mn)
因此最坏情况下复杂度是O（nm)+O((m(m-1)/2))

因此分别对比较过程和判断回路过程进行改进
1.对于比较过程一次性把边按权值大小排序O（mlogm)
2.判断是否加边从深搜改为等价类角度，每个连通的子图中的所有顶点都是一个等价类
三种实现方式
1.数组
	排序是O(mlogm) 
	初始化数组，每个结点是一个等价类
	加边，找到两个元素所在等价类o(2)
		最多合并n-1次将n个等价类变为一个O(n*(n-1))
		
	复杂度为O(mlogm)+O(n^2)+O(2m)
2.链表
	排序是O(mlogm) 
	加边，找到两个元素所在等价类o(2)
		最坏情况同样是要合并n-1次，但是每次的复杂度从便利整个数组变为每个顶点最多移动lognci ,共n顶点
	时间复杂度为`O(mlogm)+O(nlogn)+O(m)
3.树
	排序为mlogm
	将每个结点初始化成一棵树
	加边，找到两个结点的根节点，不一样的话，小树合并成大树
		通过路径压缩使树的高度变短，合并的复杂查找等价类和合并等价类复杂度加起来为O(mlogn)
	因此时间复杂度为O（mlogn)
