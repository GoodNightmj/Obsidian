1.给出算法文字描述
2.写出类C代码
3.证明他是/不是好的算法

### 同时找最大值和最小值
1.当n=2k时，将E[i]和E[i+1]进行对比，其中i =1,3...2k-1，将大的数放入A数组，小的数放入B数组，此时需要对比k次，随后在A数组中找最大值，需要比较k-1次，在B数组中找最小值，也需要比较k-1次
所以当n=2k时，一共需要比较3k-2次，即3n/2-2
当n=2k+1时，将E[i]和E[i+1]进行对比，其中i =1,3...2k-1，将大的数放入A数组，小的数放入B数组，此时需要对比k次，将最后一个数同时放入AB数组中，此时，在AB数组内部都需要比较k次，一共需要比较3k次，即，3（n-1)/2
因此，至少需要比较3n/2-2次
2.
```c++
cout
```
3.假设赢和输都是一个信息
如果x是最大值，y是最小值，说明除x之外的所有元素都在比较中输过，同理，除y之外的所有元素在所有比较中都赢过，因此，至少需要2n-2个信息
当n为偶数时，对于一次获得两个信息，只有两个数状态都为N，即既没有赢过也没有输过，而一共有n个数，因此对于两个数状态都为N的情况来说最多只有n/2次
此时还需要2n-2-n=n-2个信息需要获取，对于其他情况获得信息每次最多只能获得一个
因此至少还需要比较n-2次，因此至少要比较n/2+n-2次
当n为奇数时，一次获取两个信息最多只有(n-1)/2次
剩下需要至少2n-2-(n-1)=n-1个信息
因此至少要比较（n-1）/2 +n-1
所以最坏情况下至少要比较3n/2-2次，所以这是一个好的算法


### 找次大元
1.将n个元素建立一个有2n-1个元素的完全二叉树，其中原本元素下标为[n-1]-[2n-1],f[n]=max(f[2n],f[2n+1])来求解最大元
2.使用冒泡法在与最大元进行直接比较的元素中筛选次大元
```c++
for (int i = n, j = 2 * n - 1; i >= 1; i--,j--)

arr[j] = arr[i];

for (int last = 2 * n - 2; last >= 2;last-=2)

{

if (arr[last] > arr[last + 1])

arr[last / 2] = arr[last];

else

arr[last / 2] = arr[last + 1];

}

mx = arr[1], smx = -INF;

int i = 1;

while(i<n){

if(arr[2*i]>arr[2*i+1])

{

if(arr[2*i+1]>smx)

smx=arr[2*i+1];

i = 2 * i;

}

else{

if(arr[2*i]>smx)

smx=arr[2*i];

i = 2 * i + 1;

}

}

```
3.
对于该方法来说，找最大元使用了n-1次比较，找次大元使用了logn-1次（树高logn+1）直接输给最大元的有logn个，因此进行了logn-1次

首先，找最大值至少要比较n-1次.在找次大元的过程中要找在和最大元直接比较中输掉的，假设直接败给最大元的元素个数为x，那想得到次大元就要比较x-1次，
即证明X>=logn
设开始时每个元素权重都为1，因此权重和为n，赢后元素权重为两个权重之和，输后权重变为0，假设现在已经找到最大元
w(i)=n, 其余元素权重均为0
w(i')=w(i)+w(j)
分两种情况
i，j权重相等时，wi'=2wi
不相等时wi'>2wi
所以每个元素赢后权重都小于原本权重的2倍
假设i最后赢了k次
那么n<=2^k
k>=logn



### 一般性选择问题找第k小
1.锦标赛法选出最小值，在直接大于最小值的元素找次小
....找第几小进行几次
时间复杂度O（n+klogn）
2.代码
3.在所有节点的比较中分为关键比较和非关键比较
关键比较是能确定一个元素和第k小的元素关系的比较
可以发现，至少需要n-1个关键比较才能找到该元素元
非关键比较：要想确定第k小，就要得到k-1小于他的数和n-k个大于他的数，要做min(k-1,n-k)次比较

因此至少要n+min(k，nk+1)-2次比较


