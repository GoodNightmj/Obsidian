### 知识点
1.最小生成树性质：G=（UE，W）为一个带权连通图，T为G的一棵生成树。对任意一个不在T中的边比UV 该边属于E，则将UV加入T一定会产生回路的，若UV是该回路中权值最大的边，则树T具有MST性质
2.最优子结构性质：一个问题的最优解包含其子 问题的最优解，那么此问题具有最优子结构性 质。
![image.png](https://raw.githubusercontent.com/GoodNightmj/PicGo/master/202412142000530.png)

### 贪心算法
#### Prim算法的求解过程，算法描述，正确性证明（n^2)
1.以顶点为中心逐步拓展，先将一个初始顶点加入生成树中，然后每次选择一条权重最小并且连接生成树内部顶点和外部顶点的边，随后将新的点加入生成树，直到所有顶点都被包含
2.算法描述
	1.首先任意选择一个点v作为起点加入进生成树集合S中，并记录从v0出发的所有的边进入到优先队列中
	2.从优先队列中选择权值最小的边，其中连接该边的两个点一个需在集合S中，在将另一个点加入S中，将该最小边加入到生成树中
	3.将新加入点的所连接的边，其中排除边已经在生成树中的，将其加入优先队列中
	4.重复2，3直到所有点加入S中
3.反证法：假设prim生成的不是最小生成树
1）设prim生成的树为Go
2）假设存在Gmin使得cost（Gmin）<cost（G0）则在Gmin 中存在<u,V>不属于Go
3）.将<U、V>加入Go中可得一个环，且<u,V>不是该环的最长边（这是因为<U,V>EGmin）
4）.这与prim每次生成最短边矛盾
5）.故假设不成立，命题得证



#### Kruscal算法的求解过程，算法描述，正确性证明(eloge)
1.
	先将所有边按照权值进行从小到大排序
	初始化一个空的生成树
	依次处理排序好的边
		如果加入当前边不会形成环，即边的两个顶点位于不同连通分量时，将其加入生成树
		如果形成环，跳过这边条
	重复到生成树包含了n-1条边
2.![image.png](https://raw.githubusercontent.com/GoodNightmj/PicGo/master/202412141819865.png)

#### 在带权连通图 G=(V,E,W)中，生成树T为最小生成树， 当且仅当T具有MST性质。
1.充分性：当T为最小生成树时，有MST性质
找一个在图中但不在生成树中的一条边e，因为T是最小生成树，当把e加入树中一定会产生回路
反证：假设w(e)<w(ei)
构建一个新树T'=T-ei+e，T'仍是生成树，且wt'< wt
与T是最小生成树矛盾，所以e>=ei，即有MST性质
2.必要性：T有MST性质，T就是最小生成树
假设存在T'有一个最小生成树，它具有了MST性质
T有MST性质
因为他们都有MST性质，那么Wt=wt'
所以T也是最小生成树


#### 迪杰斯特拉算法的求解过程，算法描述，正确性证明（n^2)
1.
	定义优先队列Q来存储未确定最小路径的顶点，初始先将所有点加入到Q中
	定义集合S来表示已经确定最短路径的点，初始S为空
	重复下述步骤直到Q为空
		通过确定顶点来将S更新为顶点a
		从Q中删除a
		对于a的每个邻接顶点b，如果其属于Q中，通过边（a,b)进行松弛
		d[a]+(a,b)<d[v]，将d[v]进行更新
2.令迪杰斯特拉算法求出最短路径点的顺序为s=v0 , v1 , v2 , …, vn-1 。下面证明 算法循环了k次后，正确求出了从s到v0 , v1 , v2 , …, vk 最短路径最短路径。
对k使用数学归纳法进行证明
当k=0时，从s到s的最短路径d(s,s)=0
第k步成立，则第k+1步成立
设k+1步选择了顶点v（v是剩余集合中经过set找到的从 起点到v的最短路径）
其中v是和set中的u点相连，我们要证明dis[v]=short[v]
反证法：
假设dis[v]!=short[v]
说明存在一个未在set中的点y，short[v]=dis[y]+distance[y,v]
根据算法选点描述，dis[y]一定是>=dis[v]
与short[v]>=dis[v]
因此，不存在点y，也不存在更短的路径为全局最短路径，该选择确定的点正确

#### 哈夫曼算法的求解过程，正确性证明
输入： n 和n 个权值 {w1 , w2 , …, wn } 
输出：赫夫曼树
根据给定的 n 个权值 {w1 , w2 , …, wn }，构造 n 棵二叉树的集合 F = {T1 , T2 , … , Tn }，其中每棵二叉树中均只含一个带权值 为 w i 的 根结点，其左、右子树为空树； 
在 F 中选取其根结点的权值为最小和次小的两棵二叉树，分别 作为左、右子树构造一棵新的二叉树，并置这棵新的二叉树根结 点的权值为其左、右子树根结点的权值之和； 
从F中删去这两棵树，同时加入刚生成的新树；
重复 2 和 3 两步，直至 F 中只含一棵树为止
![image.png](https://raw.githubusercontent.com/GoodNightmj/PicGo/master/202412142031969.png)
