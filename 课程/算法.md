## 排序
### 插入排序
第一次插入，即去对比下标为0和1的两个数
	若num0>num1,使num0向右右移一位
	若num1>=num1-1，即找到了正确的插入位置，不需要变化
同理第二次插入将num2进行排序，区间0-2排序成功
共需要n-1次排序
#### 最佳时间复杂度
开始的序列就已经是有序了，这样只需要完成进行n-1次比较，时间复杂度为O(n)
#### 最差时间复杂度
恰好是完全逆序，需要1+2+3+...n-1次比较为O(n(n-1)/2)
#### 平均时间复杂度
1.求插入Ri时的平均比较次数
对于求Ri的平均比较次数来说，前面有
 0   1    2  ..... Ri-1    对于这每个空位都可以插入，有R+1个空位  
R  R  R-1  R-2  2     1    比较次数分别为1 2 ... R R 
每个空位的概率都为1/i+1 
×所有空位的比较次数之和（1+2+...R +R） 
2.求从i=1到i=n-1 Ri 平均比较次数之和


为O(n^2/4)




#### 证明Theorem 4.1： 任何一个基于关键字的比较且每一次比较最多消除一个逆序的排序算法， 最坏的情况下至少比较n(n-1)/2次， 平均情况至少比较n(n-1)/4次。

对于有n个数的序列来说，任意抽出其中两个数，即一对，有n(n-1)/2对，假如这么多对全是逆序对，那么对于每次比较最多消除一个逆序来说，至少要比对n(n-1)/2次才能消除所有逆序对
对于平均情况来说，逆序对的平均个数为n(n-1)/4，因此平均情况至少比较n(n-1)/4次。
因为他们每次最多消除一个逆序，因此，W(n),A(n)都无法进一步改进，因此
。。。


### 冒泡排序

#### 正确性证明
使用数学归纳法进行证明
1.列举前k趟排序使从后往前数k个数排列好，说明进行第k+1次时，第k+1个数也被排列好了
2.证明如果一趟排序中没有交换，则排序结束

#### 复杂度分析
 **最佳时间复杂度**：O(n)。最好的情况下（初始时序列已经是升序排列），只需经过 1 趟排序，总共经过 n 次元素之间的比较，并且不移动元素，算法就可以结束排序。因此，冒泡排序算法的最佳时间复杂度为 O(n)。
 **最坏时间复杂度**：O(n2)。最差的情况下（初始时序列已经是降序排列，或者最小值元素处在序列的最后），则需要进行 n-1趟排序，总共进行
 1+.....(n-1)次比较即
O(n(n-1)/2)，同时需要同样次的交换，因此为O(n^2)
**平均时间复杂度** ：O(n^2/4)
#### 算法改进
基本想法：在每一趟排序中，记录当前遍历过程中最后一次交换发生的位置。因为该位置之后的元素已经是有序的，所以在接下来的趟排序中，就无需再比较该部分元素。
由于每一趟排序会把最大元素移到未排序部分的末尾，最后一个交换发生位置就表示的是本趟排序中最大元素的最后位置。
因此下次排序时就可以把未排序部分的范围缩小到最后一个交换的位置


### 快速排序
假设数组的元素个数为 n 个，则快速排序的算法步骤如下：
1. 哨兵划分：选取一个基准数，将数组中比基准数大的元素移动到基准数右侧，比他小的元素移动到基准数左侧。
    1. 从当前数组中找到一个基准数 pivot（这里以当前数组第 1个元素作为基准数，即 pivot=nums[low]）。
    2. 使用指针 i 指向数组开始位置，指针 j 指向数组末尾位置。
    3. 从右向左移动指针 j，找到第 1 个小于基准值的元素。
    4. 从左向右移动指针 i，找到第 1 个大于基准数的元素。
    5. 交换指针 i、指针 j 指向的两个元素位置。
    6. 重复第 3∼5 步，直到指针 i 和指针 j 相遇时停止，最后将基准数放到两个子数组交界的位置上。
2. 递归分解：完成哨兵划分之后，对划分好的左右子数组分别进行递归排序。
    1. 按照基准数的位置将数组拆分为左右两个子数组。
    2. 对每个子数组分别重复「哨兵划分」和「递归分解」，直到各个子数组只有 1 个元素，排序结束。
![image.png](https://raw.githubusercontent.com/GoodNightmj/PicGo/master/20241209232010.png)

#### 时间复杂度分析
如果每趟排序有n个元素，那就需要n-1次的比较
![image.png](https://raw.githubusercontent.com/GoodNightmj/PicGo/master/20241209233009.png)

**最坏情况下**
![image.png](https://raw.githubusercontent.com/GoodNightmj/PicGo/master/20241209233208.png)

**平均情况下**
![image.png](https://raw.githubusercontent.com/GoodNightmj/PicGo/master/20241209233648.png)
。。。。
对其进行估算可得，平均时间复杂度为O(nlogn)


#### 改进措施
1.将小排序问题不使用快速排序使用直接插入法
2.将递归解决改为非递归
3.将基准点的选取进行随机

### 归并排序

1. **分解过程**：先递归地将当前数组平均分成两半，直到子数组长度为 1。
    1. 找到数组中心位置 mid，从中心位置将数组分成左右两个子数组 left​nums、right​nums。
    2. 对左右两个子数组left​nums、right​nums 分别进行递归分解。
    3. 最终将数组分解为 n 个长度均为 1 的有序子数组。
2. **归并过程**：从长度为 1 的有序子数组开始，依次将有序数组两两合并，直到合并成一个长度为 n 的有序数组。
    1. 使用数组变量 nums 存放合并后的有序数组。
    2. 使用两个指针 left​i、right​i 分别指向两个有序子数组left​nums、right​nums 的开始位置。
    3. 比较两个指针指向的元素，将两个有序子数组中较小元素依次存入到结果数组 num中，并将指针移动到下一位置。
    4. 重复步骤 3，直到某一指针到达子数组末尾。
    5. 将另一个子数组中的剩余元素存入到结果数组 nums 中。
    6. 返回合并后的有序数组 nums
#### 时间复杂度分析
![image.png](https://raw.githubusercontent.com/GoodNightmj/PicGo/master/20241209235528.png)

计算可得
![image.png](https://raw.githubusercontent.com/GoodNightmj/PicGo/master/202412151538623.png)

最坏为W(n)=nlogn+n-1
最好为B(n)=n/2 logn
最坏最好都为O(nlogn)

#### 改进措施
1.将小排序问题使用直接插入法
2.将递归解决改为非递归
3.将回写操作进行改进，交叉在原数组和新数组之间写
### 堆排序

#### 两种建堆方式
1.自顶向下
	1.从第一个元素开始，将其视为一个单元素堆
	2.依次将新加入的元素加入堆的末尾
	3.每次插入后进行堆调整
完全二叉树的高度为logn，因此每次调整复杂度为logn，共n次
O(nlogn)
2.自底向上
	1.确定最后一个非叶子结点
	2.从这个结点开始，因此对每个非叶子结点进行调整
	3.向根节点方向推进，最终构成完整堆
每个结点的调整取决于他的高度
高度为h的结点有2^h个
因此O(n)
最坏情况下为O(n)+O(2logn)
#### 改进
问题：原始堆排序中会交换堆顶和最后元素K，把k放到堆顶在重排
措施：不将k直接放到堆顶而是调整堆使k一直下移找到合适的位置


### 基于比较的算法
基于比较的算法中最坏情况下的时间复杂度的下界是nlogn
量级⽆法改进，只能改进系数
归并算法的w（n)上界为nlogn，因此他是最坏情况下最好的算法
#### 基于比较的排序的w(n), A(n)

| 排序  | W(n)  | A(n)  |
| --- | ----- | ----- |
| 插入  | n^2/2 | n^2/4 |
| 冒泡  | n^2/2 | n^2/4 |
| 快速  | n^2/2 | nlogn |
| 归并  | nlogn | nlogn |


### 基数排序
时间复杂度为O(位数*（基数+待排序数个数)
适用于
	位数有限（固定长度）
	要求稳定性

## 五
### 用文字描述Finding max and min的方法；用类C语言 实现Finding max and min算法；并证明你的⽅法是好 （优）的算法
1.当n=2k时，将E[i]和E[i+1]进行对比，其中i =1,3...2k-1，将大的数放入A数组，小的数放入B数组，此时需要对比k次，随后在A数组中找最大值，需要比较k-1次，在B数组中找最小值，也需要比较k-1次
所以当n=2k时，一共需要比较3k-2次，即3n/2-2
当n=2k+1时，将E[i]和E[i+1]进行对比，其中i =1,3...2k-1，将大的数放入A数组，小的数放入B数组，此时需要对比k次，将最后一个数同时放入AB数组中，此时，在AB数组内部都需要比较k次，一共需要比较3k次，即，3（n-1)/2
因此，至少需要比较3n/2-2次
2.证明是好的算法，即证明问题下界为3n/2-2
假设赢和输都是一个信息
如果x是最大值，y是最小值，说明除x之外的所有元素都在比较中输过，同理，除y之外的所有元素在所有比较中都赢过，因此，至少需要2n-2个信息
当n为偶数时
对于一次获得两个信息，只有两个数即既没有赢过也没有输过，而一共有n个数，因此对于两个数都没有赢或输（即未参与过比较)的情况来说最多只有n/2次
此时还需要`2n-2-n=n-2`个信息需要获取，对于其他情况获得信息每次最多只能获得一个
因此至少还需要比较n-2次，因此至少要比较n/2+n-2次
当n为奇数
一次获取两个信息最多只有(n-1)/2次,剩下需要至少2n-2-(n-1)=n-1个信息
因此至少要比较（n-1）/2 +n-1

所以最坏情况下至少要比较3n/2-2次，所以这是一个好的算法

### ⽤⽂字描述Finding the Second Latgest Key 法；用类C语言实现Finding the Second 法；并证明你的算法是好（ 优）的算法
1.将n个元素建立有2n-1个元素的完全二叉树，在将原本a[1]-a[n]的元素分别映射到a[n]-a[2n-1]上
2.f[n]=max(f[2n],f[2n+1])将树填满
3.树根即为最大值，再从直接和最大值相比较之下输的logn个元素中进行比较找出第二大的元素
对于该方法来说，找最大元使用了n-1次比较
找次大元使用了logn-1次（树高logn+1）直接输给最大元的有logn个
因此进行了n+logn-2次
***
证明是好的算法,即证明定理n个元素找次大元最坏至少需要比较n+log n-2次

首先，找最大值至少要比较n-1次.在找次大元的过程中要找在和最大元直接比较中输掉的，假设直接败给最大元的元素个数为x，那想得到次大元就要比较x-1次，
即证明X>=logn
设开始时每个元素权重都为1，因此权重和为n，赢后元素权重为两个权重之和，输后权重变为0，假设现在已经找到最大元
w(i)=n, 其余元素权重均为0
w(i')=w(i)+w(j)
分两种情况
i，j权重相等时，wi'=2wi
不相等时wi'>2wi
所以每个元素赢后权重都小于原本权重的2倍
假设i最后赢了k次
那么n<=2^k
k>=logn
### 证明：在最坏情况下，求n个元素中第k 小的数据元素至少需要n+min(k，n-k+1)次比较
想得到第k小的元素（设为a），前提是先得到k-1个小于该元素的数和n-k个大于他的数
即需要n-1个数都和a进行直接或间接（比如y>a,x>y)的比较，称为关键比较
而如果想得到k-1个小于a元素和n-k个大于他的数，至少要进行min(k-1,n-k)次比较才行
所以至少要进行...次比较

## 六
### 了解数组、链表
数组按索引访问O1，删除插入遍历都是O(n)
链表按索引访问、遍历On,删除插入都是O1

### 了解Array Doubling技术的性能分析
假设一开始数组大小为2，需要时将大小扩大1倍
已知当前数组中已有n元素n=2^k，当插入n+1元素时需要扩大
对于一开始的2^1元素，需要移动2^k次（越早的次数越多）
$$
\sum_{i=1}^{k-1} =2^i *(k-i) +2^1*k
$$
### 红黑树
#### 定义
1.结点除了黑色就是红色
2.根节点为黑色
3.叶子结点都是黑色
4.不能有两个连续的红色节点
5.对于任意一个节点来说，从该节点到叶子结点的都包含相同数量的黑色结点
#### 性质
红黑树保证最长路径不超过最短路径的二倍，因而近似平衡（最短路径就是全黑节点，最长路径就是一个红节点一个黑节点，当从根节点到叶子节点的路径上黑色节点相同时，最长路径刚好是最短路径的两倍）
#### 查找
因为红黑树是一颗二叉平衡树，并且查找不会破坏树的平衡，所以查找跟二叉平衡树的查找无异：
1. 从根结点开始查找，把根结点设置为当前结点；
2. 若当前结点为空，返回null；
3. 若当前结点不为空，用当前结点的key跟查找key作比较；
4. 若当前结点key等于查找key，那么该key就是查找目标，返回当前结点；
5. 若当前结点key大于查找key，把当前结点的左子结点设置为当前结点，重复步骤2；
6. 若当前结点key小于查找key，把当前结点的右子结点设置为当前结点，重复步骤2；
  ![image.png](https://raw.githubusercontent.com/GoodNightmj/PicGo/master/202412151823032.png)

#### 插入
插入操作包括两部分工作：一查找插入的位置；二插入后自平衡。
- 从根结点开始查找；
- 若根结点为空，那么插入结点作为根结点，结束。
- 若根结点不为空，那么把根结点作为当前结点；
- 若当前结点为null，返回当前结点的父结点，结束。
- 若当前结点key等于查找key，那么该key所在结点就是插入结点，更新结点的值，结束。
- 若当前结点key大于查找key，把当前结点的左子结点设置为当前结点，重复步骤4；
- 若当前结点key小于查找key，把当前结点的右子结点设置为当前结点，重复步骤4；
![image.png](https://raw.githubusercontent.com/GoodNightmj/PicGo/master/202412151831822.png)
自平衡
1.树为空树
	将结点颜色由红转为黑
2.插入结点的key值已经存在
	插入结点的Key已存在，既然红黑树总保持平衡，在插入前红黑树已经是平衡的，那么把插入结点设置为将要替代结点的颜色，再把结点的值更新就完成插入。
3.插入结点的父亲结点为黑色
	直接插入
4.插入结点的父结点为红结点
	4.1 叔叔结点存在并且为红结点
		由红黑树性质可知祖父结点一定为黑色结点，此时状况为黑红红，调整为红黑红，如果祖父的父结点是黑色则不用变，如果是红色，将祖父结点当作新插入结点继续平衡
	4.2 叔叔结点不存在或者为黑
			4.2.1插入的是父亲结点的左子树
				左孩子
				右孩子
			4.2.2 右子树
				左孩子
				右孩子
		都是通过旋转加变色解决

### 以克鲁斯卡尔求最小生成树的算法为例，分析讨论各种实现方法的时间性能
1.从m条边中选择一个权值最小的比较m-1次，判断是否有回路
2.从m-1条边中选择最小的，m-2次比较。
最坏情况为比较了(m-1)+...1=m(m-1)/2次比较
在判断是否有回路时使用深搜，时间复杂度为O（n+m）最坏情况下进行了m次，时间复杂度为O（mn)
因此最坏情况下复杂度是O（nm)+O((m(m-1)/2))

因此分别对比较过程和判断回路过程进行改进
1.对于比较过程一次性把边按权值大小排序O（mlogm)
2.判断是否加边从深搜改为等价类角度，每个连通的子图中的所有顶点都是一个等价类
三种实现方式
1.数组
	排序是O(mlogm) 
	初始化数组，每个结点是一个等价类
	加边，找到两个元素所在等价类o(2)
		最多合并n-1次将n个等价类变为一个
		每次合并找出所有等价类为i的元素修改其labelO(n)
		O(n*(n-1))
	复杂度为O(mlogm)+O(n^2)+O(2m)
2.链表
	排序是O(mlogm) 
	加边，找到两个元素所在等价类o(2)
		最坏情况同样是要合并n-1次，但是每次的复杂度从便利整个数组变为每个顶点最多移动logn次 ,共n顶点
	时间复杂度为`O(mlogm)+O(nlogn)+O(2m)
3.树
	排序为mlogm
	将每个结点初始化成一棵树
	加边，找到两个结点的根节点，不一样的话，小树合并成大树
		通过路径压缩使树的高度变短，合并的复杂查找等价类和合并等价类复杂度加起来为O(mlogn)
	因此时间复杂度为O（mlogn)
### 优先队列
定义：一种特殊的队列。在优先队列中，元素被赋予优先级，队列是0个或多个元素的集合

操作：
1）Get-min：取队列的优先级最小的元素
2）Delete-min: 删除优先级最小的
3)Insert :插入一个新元素
4)decrecase key：修改队列中元素的权值

#### 有序线性表
1.查找和删除都是O(1)，取队尾或链尾
2.插入
	数组：
		1.找到插入位置，使用二分查找等
		2.移动元素平均为（n+1）/2 
		O(n)
	链表：
		1.从head找插入位置
		2.无需移动
		O(n)
#### 堆
1.取堆顶，O（1）
2.删除堆顶，插入堆顶都是 O(logn)--调整堆
4.调整权值
	找到该元素，O(n)
		优化：使用辅助数组构建每个元素的id和堆数组的位置使找到元素的复杂度为O（2）
	修改后调整堆 O（logn）




## 七
### 图的存储方式
1.邻接矩阵
2.邻接表
### 图的深度优先搜索和广度优先搜索算法及时间复杂度分析
从某顶点出发访问所有节点且每个节点只访问一次
#### 深搜
从某个未被访问的顶点v0出发，访问他并依次访问v0的各个未被访问过的邻接点，直到图中所有与V0有路径连通的顶点都倍访问
时间复杂度
	O（n）要对每个结点检查一遍是否被访问
	对于邻接矩阵：O（n^2)对每个结点都需要考察都有哪些边，要便利整个二维数组
	对于邻接表：只会遍历存在的边，因此O(m)
O(n+m)或O（n^2+n)

#### 广搜
从某个没被访问的顶点v0出发，访问他并依次访问v0所有没被访问的邻接点，在按照这些结点的访问顺序依次取访问他们的邻接点，直到图中所有与v0路径想通的点都被访问
时间复杂度一样

### 应用
1. 连通分量
	1.1. 判断无向图是否为连通图：如果经过一次FS后，发现图中有没访问的顶点，就不是连通图
	1.2 判断有几个连通分量：遍历图选了几次出发点就说明有几个连通分量
2. 有向无环图
	2.1判断有向图中是否有回路
		1.选择一个入度为0的顶点输出
		2.删除该顶点和他发出的所有边
		3.重复1.2直到顶点全部输出或者不存在入度为0的点
		4.若图中还有剩余顶点没被删除，说明存在回路
		O(V+E)
	2.2 DFS构造拓扑排序
		一次DFS后结束的顺序为拓扑排序的逆序（最先退出DFS的点是出度为0的点
		O(V+E)
3. 生成树
	1. DFS
		从一个顶点开始递归访问当前结点的邻接点，对每条访问过的边，如果目标顶点还没有被访问，则将该边加入到生成树中，直到顶点都访问完
		O(V+E)
	2. BFS
		将起点加入队列并标记已访问，每次从队列中取出顶点，将其邻接点中还没访问过的结点放到队列中，并记录边直到队列为空
		O(V+E)
4. 二连通分量
	初始化：
	用数组 dfn[u] 表示顶点  u  被访问的时间戳。
	用数组 low[u] 表示通过顶点  u  的子树中能够回溯到的最小时间戳。
	使用栈存储当前搜索路径中的边，用于构造二连通分量。
	深度优先搜索（DFS）：
	从任意一个顶点  u  开始进行DFS。
	对于每条边  (u, v) ，如果  v  尚未访问，则递归地搜索 v ，并更新low[u] min(low[u], low[v])
	如果  low[v] >=dfn[u] ，说明  (u, v)  是割边，当前边组成的路径可以构成一个二连通分量。
	 如果  low[v] > dfn[u] ，说明  (u, v)  是桥。
	生成二连通分量：
	每当发现一个割点或桥，从栈中弹出相关的边，形成一个二连通分量。
	重复以上过程，直到所有顶点被访问。


## 八
### 知识点
1.最小生成树性质：G=（U，E，W）为一个带权连通图，T为G的一棵生成树。对任意一个不在T中的边比UV 该边属于E，则将UV加入T一定会产生回路的，若UV是该回路中权值最大的边，则树T具有MST性质
2.最优子结构性质：一个问题的最优解包含其子 问题的最优解，那么此问题具有最优子结构性 质。
### 贪心算法
#### Prim算法的求解过程，算法描述，正确性证明（n^2)
1.以顶点为中心逐步拓展，先将一个初始顶点加入生成树中，然后每次选择一条权重最小并且连接生成树内部顶点和外部顶点的边，随后将新的点加入生成树，直到所有顶点都被包含
2.算法描述
	1.首先任意选择一个点v作为起点加入进生成树集合S中，并记录从v0出发的所有的边进入到优先队列中
	2.从优先队列中选择权值最小的边且连接该边的两个点一个在集合S中，另一个点不在S中，将另一点加入S中，并将该最小边加入到生成树中
	3.将新加入点的所连接的边，其中排除边已经在生成树中的，将其加入优先队列中
	4.重复2，3直到所有点加入S中
3.反证法：假设prim生成的不是最小生成树
1）设prim生成的树为T
2）假设存在Tmin使得cost（Tmin）<cost（T）则在Tmin 中存在<u,V>不属于Go
3）将<U、V>加入Go中可得一个环，且<u,V>不是该环的最长边
4）由于Prim算法做法是每次选择优先队列中的最小边进行添加，当没有<u,v>时，不会存在比这条边更大的边。
5）故假设不成立，命题得证
#### Kruscal算法的求解过程，算法描述，正确性证明(eloge)
1.
	先将所有边按照权值进行从小到大排序
	初始化一个空的生成树
	依次处理排序好的边
		如果加入当前边不会形成环，即边的两个顶点位于不同连通分量时，将其加入生成树
		如果形成环，跳过这边条
	重复到生成树包含了n-1条边
2.![image.png](https://raw.githubusercontent.com/GoodNightmj/PicGo/master/202412141819865.png)
#### 迪杰斯特拉算法的求解过程，算法描述，正确性证明（n^2)
1.
	定义优先队列Q来存储未确定最小路径的顶点，初始先将所有点加入到Q中
	定义集合S来表示已经确定最短路径的点，初始S为空
	重复下述步骤直到Q为空
		通过确定顶点来将S更新为顶点a
		从Q中删除a
		对于a的每个邻接顶点b，如果其属于Q中，通过边（a,b)进行松弛
		d[a]+(a,b)<d[b]，将d[b]进行更新
2.令迪杰斯特拉算法求出最短路径点的顺序为s=v0 , v1 , v2 , …, vn 。下面证明 
当k=0时，从s到s的最短路径d(s,s)=0

假设在第 k 步中，算法已经正确地求出了从 s 从v0,v1​…vk​ 的最短路径，即这些顶点的最短路径已被正确计算。

我们需要证明，在第 k+1 步中选择的顶点 v也满足最短路径。设在第 k+1步中选择了顶点 v，此时 v 是与已在集合 set 中的顶点 u 相连的，并且 v 是Q中距离 s 最近的顶点。
为了证明 dis[v]=short[v]（即 v 的当前距离值等于真实的最短路径值），我们使用反证法：
假设 dis[v]≠short[v]即存在一个未在集合 set 中的点 y，使得 short[v]=dis[y]+distance[y,v]，其中 dis[y] 是从 s 到 y 的当前已知最短路径，distance[y,v]是从 y 到 v 的边的权重。
根据算法的选择规则，选择顶点 v 时，算法保证 dis[v] 是当前所有剩余点中最小的距离。如果 dis[y]+distance[y,v]=short[v]，那么根据最短路径的定义，y 的当前路径值应该大于或等于 dis[v]，即 dis[y]≥dis[v]
因此不存在点y，也不存在更短的路径为全局最短路径，该选择确定的点正确

#### 哈夫曼算法的求解过程，正确性证明
输入： n 和n 个权值 {w1 , w2 , …, wn } 
输出：赫夫曼树
根据给定的 n 个权值 {w1 , w2 , …, wn }，构造 n 棵二叉树的集合 F = {T1 , T2 , … , Tn }，其中每棵二叉树中均只含一个带权值 为 w i 的 根结点，其左、右子树为空树； 
在 F 中选取其根结点的权值为最小和次小的两棵二叉树，分别 作为左、右子树构造一棵新的二叉树，并置这棵新的二叉树根结 点的权值为其左、右子树根结点的权值之和； 
从F中删去这两棵树，同时加入刚生成的新树；
重复 2 和 3 两步，直至 F 中只含一棵树为止
证明哈夫曼算法正确性
k是字符集中字符的个数
当k=2时 C={x1,x2}，哈夫曼构造的树是最优二叉树
假设
2<=k<=k时都成立
当k=k+1时，哈夫曼构造的树仍是最优二叉树
还是设x1,x2是字符集C中频率最小的两个字符
令C'=C-x1-x2+z，其中z的频率为x1,x2之和
因此C'的规模为k，由假设得，T'是最优二叉树
将T'进行改造，为z设置两个孩子，频率为x1,x2
计算T'和T''的权值，可以得到，T''-T'=x1.f+x2.f
但因为T'已经是最优二叉树
T'=T''，因此T''为最优二叉树
那么T''就是一个有k+1个字符的且采用哈夫曼树构造的树
他是最优二叉树，因此得证
![image.png](https://raw.githubusercontent.com/GoodNightmj/PicGo/master/202412142031969.png)
#### Floyd 算法
初始化
 设图的邻接矩阵为 dist，其中 dist[i][j] 是从顶点 i 到顶点 j 的初始距离（如果 i 和 j 之间没有边，则设为无穷大）。
动态规划更新
对于每一对顶点 (i,j)，逐步检查是否通过中间点 k（其中k 为任意顶点）可以找到一条更短的路径： 
`dist[i][j]=min⁡(dist[i][j],dist[i][k]+dist[k][j]]`
这个更新过程会进行 V 次迭代（对于每个顶点 k），在每次迭代中更新所有 i,j 的最短路径。
结束：最终得到的 dist[i][j]是从任意顶点 i 到顶点 j 的最短路径。

## 十
### 给定n个矩阵的维数d[n+1]，设计动态规划算法求n个矩阵连乘的最优计算次序和对应的最优数乘次数，给出该算法的时间复杂度空间复杂度
设 `d` 为矩阵链的维度数组，`d[i-1]` 是第 `i` 个矩阵的行数，`d[i]` 是第 `i` 个矩阵的列数。
- 目标是求解最小数乘次数，并给出最优的矩阵链乘法顺序。
- `cost[i][j]` 表示计算矩阵从Ai 到Aj的最小值
$$
cost[i][j]=cost[i][k]+cost[k+1][j]+d[i−1]×d[k]×d[j]
$$
其中 i<=k< j
* `last[i][j]`存储的是求解矩阵从Ai到Aj的最小值的划分间隔
通过一步步回溯即可查找到最优计算次序
![image.png](https://raw.githubusercontent.com/GoodNightmj/PicGo/master/202412152357385.png)
时间复杂度为O(n^3)
#### 例题
A,B,C,D的维数分别为20×2,2×15,15×40和 40×3, 我们想知道计算A×B×C×D的最好次序。请给出最优矩阵乘法顺序的Cost阵与Root阵及最优矩阵乘法顺序
![1d1c7eed1f6d7693bc44db42a498e8d.jpg](https://raw.githubusercontent.com/GoodNightmj/PicGo/master/202412160020694.jpg)
### 对键值K1,K2,…,Kn查找概率p1,p2,…,pn，设计动态规划算法构造一棵二叉搜索树，使得平均查找时间最小（二叉树采用二叉链表存放），分析算法的时间复杂度和空间复杂度
定义状态  
设eij为从ki到kj这段区间的最优二叉树的期望搜索成本，wij为从ki 到kj 的概率之和
状态转移
如果我们选择某个 Kr​ 作为根节点，那么它将把问题划分成两个子问题：
左子树：从 Ki 到 Kr−1
右子树：从 Kr+1到Kj​
那么最优二叉搜索树的查找成本就是选择该节点作为根的期望查找成本：
$$
e[i][j]=min​(e[i][r−1]+e[r+1][j]+w[i][j])
$$
其中，`w[i][j]`是 Ki​ 到 Kj 的概率总和，计算公式为：
初始条件  
对于每个 i，我们有：
```
e[i][i−1]=0,w[i][i−1]=0
```
这表示如果区间为空（没有元素），成本为 0。
最终目标
我们最终的目标是计算 `e[1][n]`即整个序列的最优查找成本。
#### 例题
给定查找概率A(0.4)，B(0.08)，C(0.14)，D(0.16)，E(0.22)，（
1）求构造最优二叉搜索树的Cost阵与Root阵；（2）画出相应的最优二叉搜索树